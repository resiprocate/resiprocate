#if !defined(ConversationProfile_hxx)
#define ConversationProfile_hxx

#include <resip/dum/UserProfile.hxx>
#include <resip/stack/SdpContents.hxx>

namespace recon
{

typedef unsigned int ConversationProfileHandle;

/**
  This class extends the resip UserProfile to include Conversation 
  Manager specific settings.

  Author: Scott Godin (sgodin AT SipSpectrum DOT com)
*/

class ConversationProfile : public resip::UserProfile
{
public:  

   ConversationProfile(); 

   enum NatTraversalMode
   {
      NoNatTraversal,
      StunBindDiscovery,
      TurnUdpAllocation,
      TurnTcpAllocation,
      TurnTlsAllocation,
      Ice
   };

   /**
     Constructor

     @param baseProfile if any UserProfile settings are not set on this
                        class, then the setting will "fall through" to 
                        the base profile
   */  
   ConversationProfile(resip::SharedPtr<resip::UserProfile> baseProfile);  

   /**
    * Copy ctor
    *
    * This is used primarily by the "clone" method below. The clone method
    * is required for proper anonymous calling support.
    */
   ConversationProfile(const ConversationProfile& thatProfile);

   /**
     Get/Set the session capabilities.  Session capabilities are expressed
     as a SessionDesriptionProtocol body.  Typically this is populated as you
     would expect an SDP offer to look like that is generated by this application.

     This is used to generate SDP offers and form valid SDP answers.

     @return SdpContents representing the session capabilities
   */  
   virtual resip::SdpContents& sessionCaps();
   virtual const resip::SdpContents sessionCaps() const; 

   virtual bool& audioSupported() { return mAudioSupported; }
   virtual const bool audioSupported() const { return mAudioSupported; }

   virtual bool& videoSupported() { return mVideoSupported; }
   virtual const bool videoSupported() const { return mVideoSupported; }

   virtual resip::Data& sessionName() { return mSessionName; }
   virtual const resip::Data sessionName() const { return mSessionName; }

   /**
     Get/Set whether auto answers are allowed, if an autoanswer indication
     is found in a new inbound call request.

     @return bool True if auto answer is enabled
   */  
   virtual bool& allowAutoAnswer() { return mAllowAutoAnswer; }
   virtual const bool allowAutoAnswer() const { return mAllowAutoAnswer; }

   /**
     Get/Set whether priority auto answers are allowed, if a priority 
     autoanswer indication is found in a new inbound call request.

     @note Priority Auto Answers are indicated using the PrivAnswerMode
           SIP header

     @return bool True if priority auto answer is enabled
   */  
   virtual bool& allowPriorityAutoAnswer() { return mAllowPriorityAutoAnswer; }
   virtual const bool allowPriorityAutoAnswer() const { return mAllowPriorityAutoAnswer; }

   /** 
     Checks an Invite message for auto-answer headers against the current allow 
     settings.  
     
     @param inviteRequest SIP Invite message to check
     @param required Will return true if the auto-answer is "required"
   */
   virtual bool shouldAutoAnswer(const resip::SipMessage& inviteRequest, bool *required = 0);

   /** 
     Get/Set whether auto answer requests should be digest challenged
     or not.

     @note Requests will be challenged using the digest credentials
           set on this profile
     
     @return bool True if auto answer requests should be challenged
   */
   virtual bool& challengeAutoAnswerRequests() { return mChallengeAutoAnswerRequests; }
   virtual const bool challengeAutoAnswerRequests() const { return mChallengeAutoAnswerRequests; }

   /** 
     Get/Set whether out of dialog REFER requests should be digest 
     challenged or not.

     @note Requests will be challenged using the digest credentials
           set on this profile
     
     @return bool True if OOD REFER requests should be challenged
   */
   virtual bool& challengeOODReferRequests() { return mChallengeOODReferRequests; }
   virtual const bool challengeOODReferRequests() const { return mChallengeOODReferRequests; }

   /** 
     Get/Set the NAT traversal mode that will be used for sending/receiving media packets.
     NoNatTraversal - don't use any NAT traversal strategies - local address and port
                      are used in SDP negotiations
     StunBindDiscovery - use Binding discovery on a STUN server, to discover and use
                         "public" address and port in SDP negotiations
     TurnUdpAllocation - Use a TURN server as a media relay.  Communicate to the TURN
                         server over UDP and Allocate a UDP relay address and port to 
                         use in SDP negotiations
     TurnTcpAllocation - Use a TURN server as a media relay.  Communicate to the TURN
                         server over TCP and Allocate a UDP relay address and port to 
                         use in SDP negotiations
     TurnTlsAllocation - Use a TURN server as a media relay.  Communicate to the TURN
                         server over TLS and Allocate a UDP relay address and port to 
                         use in SDP negotiations
     
     @return NatTraversalMode
   */
   virtual NatTraversalMode& natTraversalMode() { return mNatTraversalMode; }
   virtual const NatTraversalMode natTraversalMode() const { return mNatTraversalMode; }

   /** 
     Get/Set the NAT traversal server hostname that will be used for if natTranversalMode
     is anything other than NoNatTraversal.  The server can be specified as an IP address
     or a A-Records DNS resolvable hostname.  SRV resolution is not yet supported.
     
     @return The server to use for NAT traversal
   */
   virtual resip::Data& natTraversalServerHostname() { return mNatTraversalServerHostname; }
   virtual const resip::Data natTraversalServerHostname() const { return mNatTraversalServerHostname; }

   /** 
     Get/Set the NAT traversal server port that will be used for if natTranversalMode
     is anything other than NoNatTraversal.  
     
     @return The server port to use for NAT traversal
   */
   virtual unsigned short& natTraversalServerPort() { return mNatTraversalServerPort; }
   virtual const unsigned short natTraversalServerPort() const { return mNatTraversalServerPort; }

   /** 
     Get/Set the STUN username that will be used for if natTranversalMode
     is anything other than NoNatTraversal.  The stun username/password is used for 
     both STUN and TURN server authentication.
     
     @return The STUN username
   */
   virtual resip::Data& stunUsername() { return mStunUsername; }
   virtual const resip::Data stunUsername() const { return mStunUsername; }

   /** 
     Get/Set the STUN password that will be used for if natTranversalMode
     is anything other than NoNatTraversal.  The stun username/password is used for 
     both STUN and TURN server authentication.
     
     @return The STUN password
   */
   virtual resip::Data& stunPassword() { return mStunPassword; }
   virtual const resip::Data stunPassword() const { return mStunPassword; }

   /**
    * Returns the "handle" to this object. Note that the handle may be in
    * an uninitialized state if the profile has not yet been associated
    * with a handle by way of the user agent class.
    */
   virtual ConversationProfileHandle& handle() { return mcpHandle; }
   virtual const ConversationProfileHandle handle() const { return mcpHandle; }

   /**
    * When support for anonymous calling is enabled (RFC3323), sometimes
    * you want to ALSO rewrite the "From" header in order to further conceal
    * your identity. This provides that support.
    *
    * It is provided as an option because some configurations don't like
    * the from header to be tinkered with.
    */
   virtual bool& rewriteFromHeaderIfAnonymous() { return mPrivacyRewriteFrom; }
   virtual const bool rewriteFromHeaderIfAnonymous() const { return mPrivacyRewriteFrom; }

   /**
    * This is provided in case the value of the "Privacy" header needs to be
    * modified (in most cases, it does not). The default value of this header
    * is "id".
    */
   virtual resip::Data& alternativePrivacyHeader() { return mAlternativePrivacyHeader; }
   virtual const resip::Data alternativePrivacyHeader() const { return mAlternativePrivacyHeader; }

   /**
     Get/Set the QOS setting used for signaling packets. The default value (blank) 
     should result in no QOS values. Other valid values are defined by the application.
   */  
   virtual resip::Data& signalingQOS() { return mSignalingQOS; }
   virtual const resip::Data signalingQOS() const { return mSignalingQOS; }

   /**
     Get/Set the QOS setting used for audio data packets. The default value (blank) 
     should result in no QOS values. Other valid values are defined by the application.
   */  
   virtual resip::Data& audioDataQOS() { return mAudioDataQOS; }
   virtual const resip::Data audioDataQOS() const { return mAudioDataQOS; }

   /**
    * Get/Set the QOS setting used for video data packets. The default value (blank) 
    * should result in no QOS values. Other valid values are defined by the application.
    */  
   virtual resip::Data& videoDataQOS() { return mVideoDataQOS; }
   virtual const resip::Data videoDataQOS() const { return mVideoDataQOS; }

   /**
    * If true, the SDP offer will have the c= line set to 0.0.0.0 when a RemoteParticipant is
    * removed from a Conversation.
    */
   virtual bool& useRfc2543Hold() { return mUseRfc2543Hold; }
   virtual const bool useRfc2543Hold() const { return mUseRfc2543Hold; }

protected:
   virtual UserProfile* clone() const;

private:            
   resip::SdpContents mSessionCaps; 
   bool mAudioSupported;
   bool mVideoSupported;
   bool mAllowAutoAnswer;
   bool mAllowPriorityAutoAnswer;
   bool mChallengeAutoAnswerRequests;
   bool mChallengeOODReferRequests;
   NatTraversalMode mNatTraversalMode;
   resip::Data mNatTraversalServerHostname;
   unsigned short mNatTraversalServerPort;
   resip::Data mStunUsername;
   resip::Data mStunPassword;
   ConversationProfileHandle mcpHandle;
   bool mIsAnonymous;
   bool mPrivacyRewriteFrom;
   resip::Data mAlternativePrivacyHeader;
   resip::Data mSignalingQOS;
   resip::Data mAudioDataQOS;
   resip::Data mVideoDataQOS;
   bool mUseRfc2543Hold;
   resip::Data mSessionName;
};

}

#endif


/* ====================================================================

 Copyright (c) 2007-2008, Plantronics, Inc.
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are 
 met:

 1. Redistributions of source code must retain the above copyright 
    notice, this list of conditions and the following disclaimer. 

 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution. 

 3. Neither the name of Plantronics nor the names of its contributors 
    may be used to endorse or promote products derived from this 
    software without specific prior written permission. 

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 ==================================================================== */
